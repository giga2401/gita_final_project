code,expected,built_system
greeting= input('Greeting: ').lower().strip() if 'hello' in greeting: print('$0') elif 'h' in greeting[0]: print('$20') else: print('$100'),1,False
message = input('Please provide a greeting: ').lower().strip() if 'hello' in message: print('$0') elif message.startswith('h'): print('$20') else: print('$100'),0,True
"import requests from sys import argv, exit # get response try: response = requests.get('https://api.coindesk.com/v1/bpi/currentprice.json') except requests.RequestException: exit() # get price of bitcoin res = response.json() price = res['bpi']['USD']['rate'].replace(',','') price = float(price) # check and get argument if len(argv) != 2: exit('Missing command-line argument') else: try: number = float(argv[1]) except: exit('Command-line argument is not a number') # calculate price total = number * price print(f'${total:,.4f}')",1,True
"import requests import sys # fetch data try: data = requests.get('https://api.coindesk.com/v1/bpi/currentprice.json') except requests.RequestException: sys.exit() # extract bitcoin price bitcoin_data = data.json() bitcoin_price = bitcoin_data['bpi']['USD']['rate'].replace(',', '') bitcoin_price = float(bitcoin_price) # validate command-line argument if len(sys.argv) != 2: sys.exit('Expected a single argument') else: try: quantity = float(sys.argv[1]) except ValueError: sys.exit('Argument must be a valid number') # compute total price total_amount = quantity * bitcoin_price print(f'${total_amount:,.4f}')",0,True
"import random def main(): level = get_level() score = 0 for _ in range(10): x = generate_integer(level) y = generate_integer(level) ans = str(x+y) res = 0 for i in range(4): if i == 3: print(x, '+', y, '=', ans) break print(x, '+', y, '=', end=' ') res = input() if res!=ans: print('EEE') else: score+=1 break print('Score: ', score) def get_level(): while True: try: level = input('Level: ') if level.isnumeric(): level = int(level) else: raise Exception if 0 < level and level < 4: return level else: raise Exception except: pass def generate_integer(level): if level == 1: return random.randint(0,9) elif level == 2: return random.randint(10,99) else: return random.randint(100,999) if __name__ == '__main__': main()",1,True
"import random def start_quiz(): difficulty = select_level() user_score = 0 for _ in range(10): num1 = generate_number(difficulty) num2 = generate_number(difficulty) correct_answer = str(num1 + num2) user_input = 0 for attempt in range(4): if attempt == 3: print(f'{num1} + {num2} = {correct_answer}') break print(f'{num1} + {num2} = ', end='') user_input = input() if user_input != correct_answer: print('Incorrect!') else: user_score += 1 break print(f'Your final score: {user_score}') def select_level(): while True: try: difficulty = input('Please choose a difficulty (1-3): ') if difficulty.isdigit(): difficulty = int(difficulty) else: raise ValueError if 0 < difficulty < 4: return difficulty else: raise ValueError except ValueError: pass def generate_number(difficulty): if difficulty == 1: return random.randint(0, 9) elif difficulty == 2: return random.randint(10, 99) else: return random.randint(100, 999) if __name__ == '__main__': start_quiz()",0,False
"from sys import argv, exit from tabulate import tabulate import csv def main(): filename = get_filename(argv) check_csv(filename) try: with open(filename, 'r') as file: reader = csv.reader(file) table = [] headers = list(next(reader)) for row in reader: table.append([row[0], row[1], row[2]]) # Move print statement outside the loop print(tabulate(table, headers, tablefmt='grid')) except FileNotFoundError: exit('File does not exist') except Exception as arg: exit(arg) def get_filename(arguments): if len(arguments) != 2: if len(arguments) < 2: exit('Too few command-line arguments') else: exit('Too many command-line arguments') return arguments[1] def check_csv(filename): dot = filename.find('.') if filename[dot:] != '.csv': exit('Not a CSV file') if __name__ == '__main__': main()",1,True
"import csv import sys from tabulate import tabulate def start_program(): file_path = validate_arguments(sys.argv) verify_csv(file_path) try: with open(file_path, 'r') as file: csv_reader = csv.reader(file) data = [] column_headers = list(next(csv_reader)) for row in csv_reader: data.append([row[0], row[1], row[2]]) # Print the table after processing the entire file print(tabulate(data, column_headers, tablefmt='grid')) except FileNotFoundError: sys.exit('Error: File not found') except Exception as error: sys.exit(f'An error occurred: {error}') def validate_arguments(args): if len(args) != 2: if len(args) < 2: sys.exit('Error: Too few arguments provided') else: sys.exit('Error: Too many arguments provided') return args[1] def verify_csv(file_name): if not file_name.endswith('.csv'): sys.exit('Error: File must have a .csv extension') if __name__ == '__main__': start_program()",0,True
"from datetime import date import inflect import sys import re def main(): inpt=input('Date of Birth: ') print(get_min(inpt)) def get_min(inpt): # gets dates from input using regex if search := re.search(r'^(\d{4})-(\d{2})-(\d{2})$',inpt): inpt=list(search.groups()) else: sys.exit('Invalid date') # converts str into int and checks valid date inpt_bday = convert_and_check(inpt) # today's date today = date.today() # bday bday = date(inpt_bday[0], inpt_bday[1], inpt_bday[2]) # computes no of days diff = bday - today no_of_days = -int(diff.days) # computes days into minutes minutes = no_of_days * 24 * 60 # converts into words inf = inflect.engine() min_words = inf.number_to_words(minutes) # remove 'and' and capitalize min_words = min_words.replace(' and','').capitalize() # return return min_words + ' minutes' def convert_and_check(day): # convert str to int day = list(map(int, day)) # check valid date and month if day[1] < 0 or day[1] > 12: sys.exit('Invalid date') elif day[2] < 0 or day[2] > 31: sys.exit('Invalid date') return day if __name__ == '__main__': main()",1,True
"import sys import re from datetime import date import inflect def start_program(): dob = input('Enter your Date of Birth (YYYY-MM-DD): ') print(calculate_age_in_minutes(dob)) def calculate_age_in_minutes(birthdate): # Match the input date format using regex if match := re.match(r'^(\d{4})-(\d{2})-(\d{2})$', birthdate): date_parts = list(match.groups()) else: sys.exit('Error: Invalid date format') # Convert the date and validate it birth_date = validate_and_convert(date_parts) # Get the current date today = date.today() # Create a date ob",0,True
"#include #include #include #include #include int main(int argc, string argv[]) { bool key = true; //checks if all characters in the second argument are digits if (argc >= 2) { for (int i = 0, n = strlen(argv[1]); i < n; i++) { if (!isdigit(argv[1][i])) { key = false; } } } //if there are two main arguments, and a key for just digits if (argc == 2 && key == true) { //if k is > 26, store the division remainder instead int keyc = atoi(argv[1]) % 26; string plaintext = get_string('plaintext: '); printf('ciphertext: '); for (int i = 0, n = strlen(plaintext); i < n; i++) { //stores the integer equivalent to the sum int cipheri = (plaintext[i] + keyc); char cipher = plaintext[i] + keyc; //if it exceeds the last letter, it decreases 26 to be the corresponding if (islower(plaintext[i])) { if (cipheri > 'z') { printf('%c', cipher - 26); } else { printf('%c', cipher); } } else if (isupper(plaintext[i])) { if (cipheri > 'Z') { printf('%c', cipher - 26); } else { printf('%c', cipher); } } else { //if it is not alphabetic, print the way it is printf('%c', plaintext[i]); } } printf('\n'); return 0; } else { printf('Usage: ./caesar key\n'); return 1; } }",1,True
"#include #include #include #include #include int main(int argc, string argv[]) { bool is_digit_key = true; // Check if the second argument contains only digits if (argc == 2) { for (int i = 0, len = strlen(argv[1]); i < len; i++) { if (!isdigit(argv[1][i])) { is_digit_key = false; } } } // Proceed if there is exactly one argument and it contains only digits if (argc == 2 && is_digit_key) { int shift_value = atoi(argv[1]) % 26; // Get the effective shift within 26 string message = get_string('Enter text: '); // User input message printf('Encrypted text: '); // Loop through each character in the plaintext for (int i = 0, len = strlen(message); i < len; i++) { char current_char = message[i]; // Encrypt lowercase characters if (islower(current_char)) { char shifted_char = current_char + shift_value; // Wrap around if it goes past 'z' if (shifted_char > 'z') { printf('%c', shifted_char - 26); } else { printf('%c', shifted_char); } } // Encrypt uppercase characters else if (isupper(current_char)) { char shifted_char = current_char + shift_value; // Wrap around if it goes past 'Z' if (shifted_char > 'Z') { printf('%c', shifted_char - 26); } else { printf('%c', shifted_char); } } else { // Non-alphabetic characters remain unchanged printf('%c', current_char); } } printf('\n'); return 0; } else { // Invalid argument count or key format printf('Usage: ./caesar key\n'); return 1; } }",0,True
"#include #include #include // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name; int votes; } candidate; // Array of candidates candidate candidates[MAX]; // Number of candidates int candidate_count; // Function prototypes bool vote(string name); void print_winner(void); int main(int argc, string argv[]) { // Check for invalid usage if (argc < 2) { printf('Usage: plurality [candidate ...]\n'); return 1; } // Populate array of candidates candidate_count = argc - 1; if (candidate_count > MAX) { printf('Maximum number of candidates is %i\n', MAX); return 2; } for (int i = 0; i < candidate_count; i++) { candidates[i].name = argv[i + 1]; candidates[i].votes = 0; } int voter_count = get_int('Number of voters: '); // Loop over all voters for (int i = 0; i < voter_count; i++) { string name = get_string('Vote: '); // Check for invalid vote if (!vote(name)) { printf('Invalid vote.\n'); } } // Display winner of election print_winner(); } // Update vote totals given a new vote bool vote(string name) { // Checks if the vote is valid for (int i = 0; i < candidate_count; i++) { if (strcmp(name, candidates[i].name) == 0) { // Increases votes by 1 candidates[i].votes += 1; return true; } } return false; } // Print the winner (or winners) of the election void print_winner(void) { int winner_votes = 0; // Compares all values and stores the most votes for (int i = 0; i < candidate_count; i++) { if (candidates[i].votes > candidates[i - 1].votes) { winner_votes = candidates[i].votes; } } // Print everyone with the most votes for (int i = 0; i < candidate_count; i++) { if (candidates[i].votes == winner_votes) { printf('%s\n', candidates[i].name); } } return; }",1,True
"#include #include #include // Maximum allowed candidates #define MAX_CANDIDATES 9 // Candidate structure holds name and vote count typedef struct { string name; int vote_count; } Candidate; // Array to store candidate information Candidate candidates[MAX_CANDIDATES]; // Total number of candidates int total_candidates; // Function prototypes bool record_vote(string name); void announce_winner(void); int main(int argc, string argv[]) { // Check for valid usage if (argc < 2) { printf('Usage: election [candidate ...]\n'); return 1; } // Initialize candidates from command-line arguments total_candidates = argc - 1; if (total_candidates > MAX_CANDIDATES) { printf('The maximum number of candidates is %i\n', MA",0,True
"double calculate(const struct rusage *b, const struct rusage *a); int main(int argc, char *argv[]) { // Check for correct number of args if (argc != 2 && argc != 3) { printf('Usage: ./speller [DICTIONARY] text\n'); return 1; } // Structures for timing data struct rusage before, after; // Benchmarks double time_load = 0.0, time_check = 0.0, time_size = 0.0, time_unload = 0.0; // Determine dictionary to use char *dictionary = (argc == 3) ? argv[1] : DICTIONARY; // Load dictionary getrusage(RUSAGE_SELF, &before); bool loaded = load(dictionary); getrusage(RUSAGE_SELF, &after); // Exit if dictionary not loaded if (!loaded) { printf('Could not load %s.\n', dictionary); return 1; } // Calculate time to load dictionary time_load = calculate(&before, &after); // Try to open text char *text = (argc == 3) ? argv[2] : argv[1]; FILE *file = fopen(text, 'r'); if (file == NULL) { printf('Could not open %s.\n', text); unload(); return 1; } // Prepare to report misspellings printf('\nMISSPELLED WORDS\n\n');",1,True
"// Prepare to report misspelled words printf('\nMISSPELLED WORDS\n\n'); char word[45]; // Maximum word length for checking int word_count = 0; // Start reading the file and checking each word getrusage(RUSAGE_SELF, &before); while (fscanf(file, '%44s', word) == 1) { // Convert the word to lowercase for comparison for (int i = 0, n = strlen(word); i < n; i++) { word[i] = tolower(word[i]); } // Check if the word is misspelled if (!check(word)) { printf('%s\n', word); } word_count++; } getrusage(RUSAGE_SELF, &after); // Calculate time for checking words time_check = calculate(&before, &after); // Calculate the size of the dictionary getrusage(RUSAGE_SELF, &before); int dictionary_size = dictionary_size(); // Assuming dictionary_size function is implemented getrusage(RUSAGE_SELF, &after); // Calculate time taken to get dictionary size time_size = calculate(&before, &after); // Unload the dictionary getrusage(RUSAGE_SELF, &before); unload(); getrusage(RUSAGE_SELF, &after); // Calculate time taken to unload the dictionary time_unload = calculate(&before, &after); // Output timing statistics printf('\nTiming Information:\n'); printf('Load Time: %.6f seconds\n', time_load); printf('Check Time: %.6f seconds\n', time_check); printf('Dictionary Size Time: %.6f seconds\n', time_size); printf('Unload Time: %.6f seconds\n', time_unload); // Print the number of words processed printf('\nTotal words processed: %d\n', word_count); fclose(file);",0,False
SELECT DISTINCT name FROM people JOIN stars ON stars.person_id = people.id JOIN movies ON movies.id = stars.movie_id WHERE movies.title IN (SELECT DISTINCT title FROM movies JOIN stars ON stars.movie_id = movies.id JOIN people ON people.id = stars.person_id WHERE people.name = 'Kevin Bacon') AND people.name != 'Kevin Bacon';,1,True
SELECT DISTINCT p.name FROM people p JOIN stars s ON s.person_id = p.id JOIN movies m ON m.id = s.movie_id WHERE m.title IN ( SELECT DISTINCT m2.title FROM movies m2 JOIN stars s2 ON s2.movie_id = m2.id JOIN people p2 ON p2.id = s2.person_id WHERE p2.name = 'Kevin Bacon' ) AND p.name != 'Kevin Bacon';,0,True
SELECT title FROM movies JOIN stars ON stars.movie_id = movies.id JOIN people ON people.id = stars.person_id WHERE people.name = 'Johnny Depp' AND movies.title IN( SELECT title FROM movies JOIN stars ON stars.movie_id = movies.id JOIN people ON people.id = stars.person_id WHERE people.name = 'Helena Bonham Carter');,1,True
SELECT m.title FROM movies m JOIN stars s ON s.movie_id = m.id JOIN people p ON p.id = s.person_id WHERE p.name = 'Johnny Depp' AND m.title IN ( SELECT m2.title FROM movies m2 JOIN stars s2 ON s2.movie_id = m2.id JOIN people p2 ON p2.id = s2.person_id WHERE p2.name = 'Helena Bonham Carter' );,0,True
import stanford.karel.*; public class CheckerboardKarel extends SuperKarel{ public void run() { while ( leftIsClear() | rightIsClear() | frontIsClear() ) { FillRow(); turnLeft(); if ( frontIsClear() ){ BeeperEast(); }else{ break; } FillRow(); turnRight(); if ( frontIsClear() ) { BeeperWest(); }else{ break; } } } private void FillRow() { putBeeper(); while ( frontIsClear() ) { move(); if ( frontIsClear() ) { move(); putBeeper(); } } } private void BeeperEast() { if ( beepersPresent() ) { move(); turnLeft(); if ( frontIsClear() ){ move(); }else{ turnRight(); move(); } }else{ move(); turnLeft(); } } private void BeeperWest() { if ( beepersPresent() ) { move(); turnRight(); if (frontIsClear() ) { move(); }else{ turnRight(); move(); } }else{ move(); turnRight(); } } },1,True
import stanford.karel.*; public class CheckerboardKarel extends SuperKarel { public void run() { while (frontIsClear()) { fillRow(); // Fill a row with beepers turnLeft(); // Turn to face the next row if (frontIsClear()) { move(); // Move to the next row placeBeeperEast(); // Place beeper for east side (if needed) } else { break; } fillRow(); // Fill the row again turnRight(); // Turn to face the next row if (frontIsClear()) { move(); // Move to the next row placeBeeperWest(); // Place beeper for west side (if needed) } else { break; } } } // Function to fill a row with beepers on alternating squares private void fillRow() { putBeeper(); // Place the first beeper while (frontIsClear()) { move(); // Move to the next square if (frontIsClear()) { move(); // Move two steps if possible putBeeper(); // Place a beeper } } } // Function to place a beeper on the east side of the row private void placeBeeperEast() { if (beepersPresent()) { move(); turnLeft(); if (frontIsClear()) { move(); } else { turnRight(); move(); } } else { move(); turnLeft(); } } // Function to place a beeper on the west side of the row private void placeBeeperWest() { if (beepersPresent()) { move(); turnRight(); if (frontIsClear()) { move(); } else { turnRight(); move(); } } else { move(); turnRight(); } } },0,True
import acm.program.*; public class FindRange extends ConsoleProgram { private static final int SENTINEL = 0; public void run() { println('This program finds smallest and largest Integers.'); int smallest; int largest; int value = readInt('? '); if (value != 0) { smallest = value; largest = value; while ( value != SENTINEL ) { if (value <= smallest) smallest = value; if (value >= largest) largest = value; value = readInt('? '); } println('Smallest: '+smallest); println('Largest: '+largest); }else{ println('No vlaue is enterd.'); } } },1,True
import acm.program.*; public class FindRange extends ConsoleProgram { public void run() { println('This program finds the smallest and largest numbers.'); int smallest = Integer.MAX_VALUE; int largest = Integer.MIN_VALUE; boolean hasNumbers = false; while (true) { int currentNumber = readInt('Enter a number (enter 0 to stop): '); if (currentNumber == 0) { break; } if (!hasNumbers) { smallest = largest = currentNumber; hasNumbers = true; } else { if (currentNumber < smallest) { smallest = currentNumber; } if (currentNumber > largest) { largest = currentNumber; } } } if (hasNumbers) { println('The smallest number is: ' + smallest); println('The largest number is: ' + largest); } else { println('No valid numbers were entered.'); } } },0,True
"import acm.graphics.*; import acm.program.*; import acm.util.*; import java.awt.*; public class Hangman extends ConsoleProgram { //private HangmanLexicon word; private RandomGenerator rgen = new RandomGenerator(); //Initiating RandomGenerator rgen variable private int gusess; private String incorrectGusess = ''; private String word; private String newWord = ''; private String returnStr; private String inp; private HangmanCanvas canvas; private String secWord = ''; private String old = ''; public void init() { canvas = new HangmanCanvas(); add(canvas); } public void run() { /* You fill this in */ HangmanLexicon word1 = new HangmanLexicon(); int count = word1.getWordCount(); println(count+' words loaded'); word = word1.getWord(rgen.nextInt(0, count-1)); canvas.reset(); //word = 'FUZZY'; //println(word); gusess = 8; displayStatments(word); while(gusess > 0) { userInput(); if (secWord.equals(partialWord(word, newWord))) { println('You won!!!!'); break; } println('You left with '+gusess+' gussess'); } if (newWord.length() != word.length()) println('You looooooooose\n'+'The word was '+word); } private void displayStatments(String str) { println('Welcome to Hangman!'); println('The word looks like this: '+dashes(str)); println('you left with '+gusess+' guesess'); } private String dashes(String str1) { returnStr = ''; //println(str1); for( int i = 0;i < str1.length(); i++) { returnStr += '- '; secWord += str1.substring(i,i+1)+' '; } return returnStr; } private void userInput() { inp = readLine('Your Guess: '); if ('qwertyuiopasdfghjklzxcvbnm'.contains(inp.toLowerCase()) && (inp.length() == 1)) { old = partialWord(word, newWord); if (word.contains(inp.toUpperCase())) { newWord += inp.toUpperCase(); }else{ gusess--; incorrectGusess += inp.toUpperCase(); println('There are no '+inp+'\'s in the word');} canvas.displayWord(partialWord(word, newWord)); canvas.noteIncorrectGuess(incorrectGusess); println('The word now looks like this '+partialWord(word, newWord)); }else{println('Enter valid input.');} } private String partialWord(String str1, String str2) { String result = ''; for (int i = 0; i < str1.length(); i++) { //println(str1.substring(i,i+1)); if (str2.contains(str1.substring(i,i+1))){ result += str1.substring(i,i+1)+' '; }else { result += '- '; } } return result; } }",1,True
"import acm.graphics.*; import acm.program.*; import acm.util.*; import java.awt.*; public class Hangman extends ConsoleProgram { private RandomGenerator rgen = new RandomGenerator(); // Random number generator private int remainingGuesses; private String incorrectGuesses = ''; private String secretWord; private String revealedWord = ''; private String userGuess; private HangmanCanvas canvas; public void init() { canvas = new HangmanCanvas(); add(canvas); } public void run() { HangmanLexicon lexicon = new HangmanLexicon(); int totalWords = lexicon.getWordCount(); println(totalWords + ' words loaded'); secretWord = lexicon.getWord(rgen.nextInt(0, totalWords - 1)); canvas.reset(); remainingGuesses = 8; showWelcomeMessage(secretWord); while (remainingGuesses > 0) { processUserGuess(); if (",0,True
"import acm.io.*; import acm.program.*; import acm.util.*; import java.util.*; public class YahtzeeSolution extends GraphicsProgram implements YahtzeeConstants { /* Private instance variables */ private int nPlayers; //number of players private String[] playerNames; //an array of Player names private YahtzeeDisplay display; private RandomGenerator rgen = new RandomGenerator(); //random number generator private int[] dieResults = new int [N_DICE]; //stores the most recently rolled dice numbers private int[][] categoryScores; //stores the score for each category for each player private int category; //selected category private int[][] selectedCategories; //stores the already selected categories public static void main(String[] args) { new YahtzeeSolution().start(args); } public void run() { IODialog dialog = getDialog(); nPlayers = dialog.readInt('Enter number of players'); while(true) { if(nPlayers <= MAX_PLAYERS) break; nPlayers = dialog.readInt('You can only enter up to ' + MAX_PLAYERS +' number of players. Enter number of players'); } playerNames = new String[nPlayers]; categoryScores = new int [nPlayers + 1][N_CATEGORIES+1]; selectedCategories = new int[nPlayers+1][N_CATEGORIES+1]; for (int i = 1; i <= nPlayers; i++) { playerNames[i - 1] = dialog.readLine('Enter name for player ' + i); } display = new YahtzeeDisplay(getGCanvas(), playerNames); playGame(); } private void playGame() { for(int i = 0; i < N_SCORING_CATEGORIES; i++) { for(int j=1; j <= nPlayers; j++) { initializeFirstRoll(j); secondAndThirdRoll(j); selectCategory(j); } } calculateResults(); calculateWinner(); } /* In the beginning of a players turn, * the player clicks on 'Roll Dice', * the Dice results are displayed and * stored in the diceResults array */ private void initializeFirstRoll(int playerNumber) { for(int i = 0; i < N_DICE; i++) { int dieRoll = rgen.nextInt(1,6); dieResults[i] = dieRoll; } display.printMessage(playerNames[playerNumber - 1] + ''s turn! Click the ' + '\'Roll Dice\' ' + 'button to roll the dice.'); display.waitForPlayerToClickRoll(playerNumber); display.displayDice(dieResults); } /* For the second and third roll, * the player selects the dice he or she wants to re-roll, * the selected dice are re-rolled, and the new * dice values are displayed and stored in the diceResults array */ private void secondAndThirdRoll(int playerNumber) { for (int i = 0; i < 2; i++) { display.printMessage('Select the dice you wish to re-roll and click ' + '\'Roll Again\''); display.waitForPlayerToSelectDice(); for(int j = 0; j < N_DICE; j++) { if(display.isDieSelected(j) == true) { int dieRoll = rgen.nextInt(1,6); dieResults[j] = dieRoll; } } display.displayDice(dieResults); } } /* Pre-condition: The player has rolled the dice three times. * The player selects the category for the dice. * The player cannot select a category that he/she already chose in a previous turn.*/ private void selectCategory(int playerNumber) { while(true) { display.printMessage('Select a category for this roll'); category = display.waitForPlayerToSelectCategory(); if(selectedCategories[playerNumber][category] == 0) { calculateCategoryScore(playerNumber); break; } } } /* Pre-condition: The user selected a category he/she has not previously selected. * Assigns 1 to the selectedCategories array to keep track of selected categories. * Checks to see if the selected category matches the dice configuration, * and calculates the score. If it does not match, assigns the score of 0. * Post-condition: Shows the score category and total score in the scorecard. */ private void calculateCategoryScore(int playerNumber) { selectedCategories[playerNumber][category] = 1; int totalScore; if(checkCategory(dieResults, category) == true) { setCategoryScore(playerNumber, category); int score = categoryScores[playerNumber][category]; display.updateScorecard(category, playerNumber, score); calculateTotalScores(playerNumber); totalScore = categoryScores[playerNumber][TOTAL]; display.updateScorecard(TOTAL, playerNumber, totalScore); } else { categoryScores[playerNumber][category] = 0; display.updateScorecard(category, playerNumber, 0); calculateTotalScores(playerNumber); totalScore = categoryScores[playerNumber][TOTAL]; display.updateScorecard(TOTAL, playerNumber, totalScore); } } /*sets the score in the categoryScores matrix for each player based on the scoring category they chose after rolling the dice*/ private void setCategoryScore(int playerNumber, int category) { int score = 0; if(category >= ONES && category <= SIXES) { for(int i = 0; i < N_DICE; i++) { if(dieResults[i] == category) { score += category; } } } else if(category == THREE_OF_A_KIND || category == FOUR_OF_A_KIND || category == CHANCE) { for(int i = 0; i < N_DICE; i++) { score += dieResults[i]; } } else if(category == FULL_HOUSE) { score = 25; } else if(category == SMALL_STRAIGHT) { score = 30; } else if(category == LARGE_STRAIGHT) { score = 40; } else if(category == YAHTZEE) { score = 50; } categoryScores[playerNumber][category] = score; } /*calculates the total score for each player and updates the scorecard*/ private void calculateTotalScores(int playerNumber) { int total = 0; for(int i = ONES; i <= SIXES; i++) { total += categoryScores[playerNumber][i]; } if(total >= 63) { categoryScores[playerNumber][UPPER_BONUS] = 35; } display.updateScorecard(UPPER_BONUS, playerNumber, categoryScores[playerNumber][UPPER_BONUS]); categoryScores[playerNumber][TOTAL] = total + categoryScores[playerNumber][UPPER_BONUS]; display.updateScorecard(TOTAL, playerNumber, categoryScores[playerNumber][TOTAL]); } /*calculates the final results for all players and updates the scorecard*/ private void calculateResults() { for(int i = 1; i <= nPlayers; i++) { int total = 0; for(int j = ONES; j <= SIXES; j++) { total += categoryScores[i][j]; } if(total >= 63) { categoryScores[i][UPPER_BONUS] = 35; } display.updateScorecard(UPPER_BONUS, i, categoryScores[i][UPPER_BONUS]); categoryScores[i][TOTAL] = categoryScores[i][TOTAL] + categoryScores[i][UPPER_BONUS]; display.updateScorecard(TOTAL, i, categoryScores[i][TOTAL]); } } /* Pre-condition: The game has ended, and all the final scores have been added up. * Calculates which player has the highest score and what the highest score is * and prints that information in a message at the very end of the game.*/ private void calculateWinner() { int winningScore = 0; int winningPlayerNumber = 0; for(int i = 1; i<=nPlayers; i++) { int x = categoryScores[i][TOTAL]; if( x > winningScore) { winningScore = x; winningPlayerNumber = i - 1; } } display.printMessage('Congratulations, ' + playerNames[winningPlayerNumber] + ', you're the winner with a total score of ' + winningScore + '!'); } /* Pre-condition: The player has finished rolling the dice and selects a category. * This method returns true if the selected category matches * to the actual category correctly, and false if it does not match. */ private boolean checkCategory(int[] dice, int category) { boolean categoryMatch = false; if(category >= ONES && category <= SIXES || category == CHANCE) { categoryMatch = true; } else { //creates an array for each possible dice value (1-6) ArrayList ones = new ArrayList(); ArrayList twos = new ArrayList(); ArrayList threes = new ArrayList(); ArrayList fours = new ArrayList(); ArrayList fives = new ArrayList(); ArrayList sixes = new ArrayList(); /*goes through each rolled die and puts 1 as a place-holder into the appropriate ArrayList * e.g. if the first die value is 1, then 1 is added to the ones ArrayList or * if the second die value is 5, then 1 is added to the fives ArrayList*/ for(int i = 0; i < N_DICE; i++) { if(dice[i] == 1) { ones.add(1); } else if(dice[i] == 2) { twos.add(1); } else if(dice[i] == 3) { threes.add(1); } else if(dice[i] == 4) { fours.add(1); } else if(dice[i] == 5) { fives.add(1); } else if(dice[i] == 6) { sixes.add(1); } } if(category == THREE_OF_A_KIND) { if(ones.size() >= 3 || twos.size() >= 3 || threes.size() >= 3 || fours.size() >= 3 || fives.size() >= 3 || sixes.size() >= 3) { categoryMatch = true; } } else if(category == FOUR_OF_A_KIND) { if(ones.size() >= 4 || twos.size() >= 4 || threes.size() >= 4 || fours.size() >= 4 || fives.size() >= 4 || sixes.size() >= 4) { categoryMatch = true; } } else if(category == YAHTZEE) { if(ones.size() == 5 || twos.size() == 5 || threes.size() == 5 || fours.size() == 5 || fives.size() == 5 || sixes.size() == 5) { categoryMatch = true; } } else if(category == FULL_HOUSE) { if(ones.size() == 3 || twos.size() == 3 || threes.size() == 3 || fours.size() == 3 || fives.size() == 3 || sixes.size() == 3) { if(ones.size() == 2 || twos.size() == 2 || threes.size() == 2 || fours.size() == 2 || fives.size() == 2 || sixes.size() == 2) { categoryMatch = true; } } } else if(category == LARGE_STRAIGHT) { if(ones.size() == 1 && twos.size() == 1 && threes.size() == 1 && fours.size() == 1 && fives.size() == 1){ categoryMatch = true; } else if(twos.size() == 1 && threes.size() == 1 && fours.size() == 1 && fives.size() == 1 && sixes.size() == 1) { categoryMatch = true; } } else if(category == SMALL_STRAIGHT) { if(ones.size() >= 1 && twos.size() >= 1 && threes.size() >= 1 && fours.size() >= 1) { categoryMatch = true; } else if(twos.size() >= 1 && threes.size() >= 1 && fours.size() >= 1 && fives.size() >= 1) { categoryMatch = true; } else if(threes.size() >= 1 && fours.size() >= 1 && fives.size() >= 1 && sixes.size() >= 1) { categoryMatch = true; } } } return categoryMatch; } }",1,True
"import acm.io.*; import acm.program.*; import acm.util.*; import java.util.*; public class YahtzeeGame extends GraphicsProgram implements YahtzeeConstants { private int numPlayers; private String[] playerNames; private YahtzeeDisplay display; private RandomGenerator randGen = new RandomGenerator(); private int[] currentRoll = new int[N_DICE]; private int[][] scores; private int[][] selectedCategories; private int currentCategory; public static void main(String[] args) { new YahtzeeGame().start(args); } public void run() { IODialog dialog = getDialog(); numPlayers = dialog.readInt('Enter the number of players'); while (numPlayers > MAX_PLAYERS) { numPlayers = dialog.readInt('You can have up to ' + MAX_PLAYERS + ' players. Enter a valid number of players.'); } playerNames = new String[numPlayers]; scores = new int[numPlayers + 1][N_CATEGORIES + 1]; selectedCategories = new int[numPlayers + 1][N_CATEGORIES + 1]; for (int i = 1; i <= numPlayers; i++) { playerNames[i - 1] = dialog.readLine('Enter the name of player ' + i); } display = new YahtzeeDisplay(getGCanvas(), playerNames); playGame(); } private void playGame() { for (int round = 0; round < N_SCORING_CATEGORIES; round++) { for (int player = 1; player <= numPlayers; player++) { performPlayerTurn(player); } } calculateFinalScores(); determineWinner(); } private void performPlayerTurn(int playerNum) { rollDiceForPlayer(playerNum); reRollDice(playerNum); chooseCategoryForScore(playerNum); } private void rollDiceForPlayer(int playerNum) { for (int i = 0; i < N_DICE; i++) { currentRoll[i] = randGen.nextInt(1, 6); } display.printMessage(playerNames[playerNum - 1] + ''s turn! Click \'Roll Dice\' to roll.'); display.waitForPlayerToClickRoll(playerNum); display.displayDice(currentRoll); } private void reRollDice(int playerNum) { for (int i = 0; i < 2; i++) { display.printMessage('Select the dice to re-roll and click \'Roll Again\''); display.waitForPlayerToSelectDice(); for (int j = 0; j < N_DICE; j++) { if (display.isDieSelected(j)) { currentRoll[j] = randGen.nextInt(1, 6); } } display.displayDice(currentRoll); } } private void chooseCategoryForScore(int playerNum) { while (true) { display.printMessage('Select a category for this roll'); currentCategory = display.waitForPlayerToSelectCategory(); if (selectedCategories[playerNum][currentCategory] == 0) { computeScoreForCategory(playerNum); break; } } } private void computeScoreForCategory(int playerNum) { selectedCategories[playerNum][currentCategory] = 1; int score = 0; if (isCategoryValid(currentRoll, currentCategory)) { score = calculateCategoryScore(currentRoll, currentCategory); scores[playerNum][currentCategory] = score; display.updateScorecard(currentCategory, playerNum, score); } else { scores[playerNum][currentCategory] = 0; display.updateScorecard(currentCategory, playerNum, 0); } updateTotalScore(playerNum); } private boolean isCategoryValid(int[] dice, int category) { boolean valid = false; if (category >= ONES && category <= SIXES || category == CHANCE) { valid = true; } else { ArrayList ones = new ArrayList<>(); ArrayList twos = new ArrayList<>(); ArrayList threes = new ArrayList<>(); ArrayList fours = new ArrayList<>(); ArrayList fives = new ArrayList<>(); ArrayList sixes = new ArrayList<>(); for (int die : dice) { switch (die) { case 1: ones.add(1); break; case 2: twos.add(1); break; case 3: threes.add(1); break; case 4: fours.add(1); break; case 5: fives.add(1); break; case 6: sixes.add(1); break; } } if (category == THREE_OF_A_KIND && (ones.size() >= 3 || twos.size() >= 3 || threes.size() >= 3 || fours.size() >= 3 || fives.size() >= 3 || sixes.size() >= 3)) { valid = true; } else if (category == FOUR_OF_A_KIND && (ones.size() >= 4 || twos.size() >= 4 || threes.size() >= 4 || fours.size() >= 4 || fives.size() >= 4 || sixes.size() >= 4)) { valid = true; } else if (category == YAHTZEE && (ones.size() == 5 || twos.size() == 5 || threes.size() == 5 || fours.size() == 5 || fives.size() == 5 || sixes.size() == 5)) { valid = true; } else if (category == FULL_HOUSE && (ones.size() == 3 || twos.size() == 3 || threes.size() == 3 || fours.size() == 3 || fives.size() == 3 || sixes.size() == 3) && (ones.size() == 2 || twos.size() == 2 || threes.size() == 2 || fours.size() == 2 || fives.size() == 2 || sixes.size() == 2)) { valid = true; } } return valid; } private int calculateCategoryScore(int[] dice, int category) { int score = 0; if (category >= ONES && category <= SIXES) { for (int die : dice) { if (die == category) { score += category; } } } else if (category == THREE_OF_A_KIND || category == FOUR_OF_A_KIND || category == CHANCE) { for (int die : dice) { score += die; } } else if (category == FULL_HOUSE) { score = 25; } else if (category == SMALL_STRAIGHT) { score = 30; } else if (category == LARGE_STRAIGHT) { score = 40; } else if (category == YAHTZEE) { score = 50; } return score; } private void updateTotalScore(int playerNum) { int upperScore = 0; int lowerScore = 0; for (int i = ONES; i <= SIXES; i++) { upperScore += scores[playerNum][i]; } for (int i = THREE_OF_A_KIND; i <= CHANCE; i++) { lowerScore += scores[playerNum][i]; } int totalScore = upperScore + lowerScore; scores[playerNum][UPPER_SCORE] = upperScore; scores[playerNum][LOWER_SCORE] = lowerScore; scores[playerNum][TOTAL] = totalScore; display.updateScorecard(UPPER_SCORE, playerNum, upperScore); display.updateScorecard(LOWER_SCORE, playerNum, lowerScore); display.updateScorecard(TOTAL, playerNum, totalScore); } private void calculateFinalScores() { for (int i = 1; i <= numPlayers; i++) { if (scores[i][UPPER_SCORE] >= 63) { scores[i][UPPER_BONUS] = 35; display.updateScorecard(UPPER_BONUS, i, 35); } scores[i][TOTAL] += scores[i][UPPER_BONUS]; display.updateScorecard(TOTAL, i, scores[i][TOTAL]); } } private void determineWinner() { int highestScore = 0; int winner = 0; for (int i = 1; i <= numPlayers; i++) { if (scores[i][TOTAL] > highestScore) { highestScore = scores[i][TOTAL]; winner = i - 1; } } display.printMessage('Congratulations, ' + playerNames[winner] + ', you're the winner with a score of ' + highestScore + '!'); } }",0,True
"import acm.program.*; import java.awt.event.*; import javax.swing.*; public class NameSurfer extends Program implements NameSurferConstants { private JTextField JText; private JButton Clear; private JButton Graph; private NameSurferDataBase DataBase; private NameSurferEntry Entry ; private NameSurferGraph canvas; //private NameSurferEntry Entry = new NameSurferEntry('Sam 58 69 99 131 168 236 278 380 467 408 466'); /* Method: init() */ /** * This method has the responsibility for reading in the data base * and initializing the interactors at the bottom of the window. */ public void init() { // You fill this in, along with any helper methods // JText = new JTextField(30); Clear = new JButton('Clear'); Graph = new JButton('Graph'); add(new JLabel('Name '),SOUTH); add(JText,SOUTH); add(Graph,SOUTH); add(Clear,SOUTH); JText.addActionListener(this); addActionListeners(); DataBase = new NameSurferDataBase(NAMES_DATA_FILE); canvas = new NameSurferGraph(); add(canvas); } /* Method: actionPerformed(e) */ /** * This class is responsible for detecting when the buttons are * clicked, so you will have to define a method to respond to * button actions. */ public void actionPerformed(ActionEvent e) { // You fill this in // if (e.getSource() == JText || e.getSource() == Graph){ Entry = DataBase.findEntry(JText.getText()); canvas.addEntry(Entry); canvas.update(); //if (Entry != null) println('Graph: ' + Entry.toString()); //println('Graph: ' + JText.getText() ); } if (e.getSource() == Clear) { canvas.clear(); canvas.update(); //println('Clear'); } } }",1,False
"import acm.program.*; import java.awt.event.*; import javax.swing.*; public class NamePopularityGraph extends Program implements NameSurferConstants { private JTextField nameTextField; private JButton clearBtn; private JButton generateGraphBtn; private NameSurferDataBase nameData; private NameSurferEntry currentEntry; private NameSurferGraph graphPanel; /* Method: init() */ /** * Initializes the graphical user interface components, * including text field, buttons, and action listeners. */ public void init() { nameTextField = new JTextField(30); clearBtn = new JButton('Clear Graph'); generateGraphBtn = new JButton('Generate Graph'); add(new JLabel('Enter Name: '), SOUTH); add(nameTextField, SOUTH); add(generateGraphBtn, SOUTH); add(clearBtn, SOUTH); // Action listeners for user interaction nameTextField.addActionListener(this); addActionListeners(); // Initialize the database and the graph panel nameData = new NameSurferDataBase(NAMES_DATA_FILE); graphPanel = new NameSurferGraph(); add(graphPanel); } /* Method: actionPerformed(e) */ /** * Responds to the user actions, including submitting a name * to generate a graph or clearing the graph. */ public void actionPerformed(ActionEvent e) { // Respond to text input submission or graph button click if (e.getSource() == nameTextField || e.getSource() == generateGraphBtn) { String inputName = nameTextField.getText().trim(); if (!inputName.isEmpty()) { currentEntry = nameData.findEntry(inputName); if (currentEntry != null) { graphPanel.addEntry(currentEntry); graphPanel.update(); } else { // If no data is found for the name, show an error message JOptionPane.showMessageDialog(this, 'Name not found in the database.', 'Error', JOptionPane.ERROR_MESSAGE); } } } // Clear the graph panel if (e.getSource() == clearBtn) { graphPanel.clear(); graphPanel.update(); } } }",0,True
