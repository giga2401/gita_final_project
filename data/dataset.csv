SNIPPET,PLAGIARIZED
"def get_average(grades):
    """"""Calculate the average of grades.""""""
    total = sum(grades)
    count = len(grades)
    return total / count if count > 0 else 0",0
"def get_average(student_grades):
    """"""Calculate the average grade of a student.""""""
    total = sum(student_grades)
-- Create a table for tracking customer orders CREATE TABLE orders ( order_id INTEGER PRIMARY KEY, customer_id INTEGER NOT NULL, order_date DATETIME DEFAULT CURRENT_TIMESTAMP, total_amount DECIMAL(10, 2) NOT NULL, status VARCHAR(20) DEFAULT 'pending', FOREIGN KEY (customer_id) REFERENCES customers(id) );
-- Create a table for customer transactions CREATE TABLE transactions ( transaction_id INTEGER PRIMARY KEY, client_id INTEGER NOT NULL, transaction_date DATETIME DEFAULT CURRENT_TIMESTAMP, amount DECIMAL(10, 2) NOT NULL, status VARCHAR(20) DEFAULT 'pending', FOREIGN KEY (client_id) REFERENCES clients(id) );,1
"#include <stdio.h>
#include <cs50.h>

int main(void)
{
    int height;
    do
    {
        height = get_int(""Height: "");
    }
    while (height < 1 || height > 8);
    
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < height - i - 1; j++)
        {
            printf("" "");
        }
        for (int j = 0; j <= i; j++)
        {
            printf(""#"");
        }
        printf(""\n"");
    }
}",1
"public class Karel extends SuperKarel {
    public void run() {
        moveToWall();
        pickAllBeepers();
        returnHome();
    }
    
    private void moveToWall() {
        while (frontIsClear()) {
            move();
        }
    }
    
    private void pickAllBeepers() {
        while (beepersPresent()) {
            pickBeeper();
        }
    }
    
    private void returnHome() {
        turnAround();
        while (frontIsClear()) {
            move();
        }
    }
}",0
"public class SteepleChase extends SuperKarel {
    public void run() {
        while (frontIsClear()) {
            if (frontIsBlocked()) {
                jumpHurdle();
            } else {
                move();
            }
        }
    }
    
    private void jumpHurdle() {
        turnLeft();
        move();
        turnRight();
        move();
        turnRight();
        move();
        turnLeft();
    }
}",0
"import csv
from tabulate import tabulate

def main():
    students = []
    with open(""students.csv"") as file:
        reader = csv.DictReader(file)
        for row in reader:
            students.append({""name"": row[""name""], ""home"": row[""home""]})
    
    for student in sorted(students, key=lambda student: student[""name""]):
        print(f""{student['name']} is from {student['home']}"")

if __name__ == ""__main__"":
    main()",1
"def main():
    x = get_int(""x: "")
    print(f""x squared is {square(x)}"")

def square(n):
    return n * n

if __name__ == ""__main__"":
    main()",0
"def main():
    # Get value from user
    x = get_int(""Enter value: "")
    # Display square of the value
    print(f""The square is {square(x)}"")

def square(n):
    # Return square of number
    return n * n

if __name__ == ""__main__"":
    main()",1
"-- Create a table for tracking customer orders
CREATE TABLE orders (
    order_id INTEGER PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);",0
"-- Create a table for customer transactions
CREATE TABLE transactions (
    transaction_id INTEGER PRIMARY KEY,
    client_id INTEGER NOT NULL,
    transaction_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    FOREIGN KEY (client_id) REFERENCES clients(id)
);",1
"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node
{
    char word[50];
    struct node *next;
}
node;

node *create_node(char *word)
{
    node *new_node = malloc(sizeof(node));
    if (new_node == NULL)
    {
        return NULL;
    }
    strcpy(new_node->word, word);
    new_node->next = NULL;
    return new_node;
}",0
"#include <cs50.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

int count_letters(string text);
int count_words(string text);
int count_sentences(string text);

int main(void)
{
    string text = get_string(""Text: "");
    
    int letters = count_letters(text);
    int words = count_words(text);
    int sentences = count_sentences(text);
    
    float L = (float) letters / words * 100;
    float S = (float) sentences / words * 100;
    
    int index = round(0.0588 * L - 0.296 * S - 15.8);
    
    if (index < 1)
    {
        printf(""Before Grade 1\n"");
    }
    else if (index >= 16)
    {
        printf(""Grade 16+\n"");
    }
    else
    {
        printf(""Grade %i\n"", index);
    }
}",0
"import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords

def process_text(text):
    # Tokenize text
    tokens = word_tokenize(text.lower())
    
    # Remove stopwords
    stop_words = set(stopwords.words('english'))
    filtered_tokens = [token for token in tokens if token not in stop_words]
    
    # Calculate frequency
    freq_dist = nltk.FreqDist(filtered_tokens)
    
    return freq_dist.most_common(10)

text = input(""Enter text to analyze: "")
result = process_text(text)
print(""Most common words:"")
for word, count in result:
    print(f""{word}: {count}"")",0
"import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords

def analyze_text(content):
    # Tokenize the content
    words = word_tokenize(content.lower())
    
    # Filter out stopwords
    english_stopwords = set(stopwords.words('english'))
    meaningful_words = [w for w in words if w not in english_stopwords]
    
    # Find word frequency
    frequency = nltk.FreqDist(meaningful_words)
    
    return frequency.most_common(10)

text = input(""Please enter text for analysis: "")
results = analyze_text(text)
print(""Top 10 words by frequency:"")
for word, count in results:
    print(f""{word}: {count}"")",1
"SELECT c.customer_name, 
       SUM(o.total_amount) as total_spending,
       COUNT(o.order_id) as order_count
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY c.customer_id
HAVING SUM(o.total_amount) > 1000
ORDER BY total_spending DESC
LIMIT 10;",0
"SELECT c.name, 
       SUM(o.amount) as total_purchases,
       COUNT(o.id) as order_count
FROM customers c
JOIN orders o ON c.id = o.customer_id
WHERE o.purchase_date BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY c.id
HAVING SUM(o.amount) > 1000
ORDER BY total_purchases DESC
LIMIT 10;",1
"public class Fibonacci {
    public static void main(String[] args) {
        int n = 10;
        System.out.println(""First "" + n + "" Fibonacci numbers:"");
        
        for (int i = 0; i < n; i++) {
            System.out.print(fibonacci(i) + "" "");
        }
    }
    
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n-1) + fibonacci(n-2);
    }
}",0
"import csv

def calculate_grade(scores):
    total = sum(scores)
    average = total / len(scores)
    
    if average >= 90:
        return 'A'
    elif average >= 80:
        return 'B'
    elif average >= 70:
        return 'C'
    elif average >= 60:
        return 'D'
    else:
        return 'F'

def main():
    students = []
    with open('scores.csv') as file:
        reader = csv.reader(file)
        for name, *scores in reader:
            scores = [int(score) for score in scores]
            grade = calculate_grade(scores)
            students.append({'name': name, 'grade': grade})
    
    for student in sorted(students, key=lambda s: s['name']):
        print(f""{student['name']}: {student['grade']}"")

if __name__ == ""__main__"":
    main()",0
"import csv

def determine_grade(points):
    average = sum(points) / len(points)
    
    if average >= 90:
        return 'A'
    elif average >= 80:
        return 'B'
    elif average >= 70:
        return 'C'
    elif average >= 60:
        return 'D'
    else:
        return 'F'

def main():
    class_data = []
    with open('student_scores.csv') as file:
        reader = csv.reader(file)
        for student_name, *scores in reader:
            numerical_scores = [int(score) for score in scores]
            letter_grade = determine_grade(numerical_scores)
            class_data.append({'name': student_name, 'grade': letter_grade})
    
    for entry in sorted(class_data, key=lambda x: x['name']):
        print(f""{entry['name']}: {entry['grade']}"")

if __name__ == ""__main__"":
    main()",1
"SELECT 
    p.product_name,
    c.category_name,
    p.price,
    p.stock_quantity,
    CASE 
        WHEN p.stock_quantity > 100 THEN 'High'
        WHEN p.stock_quantity > 50 THEN 'Medium'
        WHEN p.stock_quantity > 20 THEN 'Low'
        ELSE 'Critical'
    END as stock_level
FROM 
    products p
JOIN 
    categories c ON p.category_id = c.category_id
WHERE 
    p.price > 10
ORDER BY 
    c.category_name, p.price DESC;",0
"SELECT 
    p.name,
    c.category,
    p.unit_price,
    p.inventory,
    CASE 
        WHEN p.inventory > 100 THEN 'High'
        WHEN p.inventory > 50 THEN 'Medium'
        WHEN p.inventory > 20 THEN 'Low'
        ELSE 'Critical'
    END as stock_status
FROM 
    products p
JOIN 
    categories c ON p.category_id = c.id
WHERE 
    p.unit_price > 10
ORDER BY 
    c.category, p.unit_price DESC;",1
"#include <stdio.h>
#include <stdlib.h>

// Define linked list node
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Create new node with given data
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf(""Memory allocation failed\n"");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Insert node at the beginning
void insertFront(Node** head, int data) {
    Node* newNode = createNode(data);
    newNode->next = *head;
    *head = newNode;
}

// Print all nodes
void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf(""%d -> "", current->data);
        current = current->next;
    }
    printf(""NULL\n"");
}",0
"public class BinarySearchTree {
    class Node {
        int key;
        Node left, right;
        
        public Node(int item) {
            key = item;
            left = right = null;
        }
    }
    
    Node root;
    
    BinarySearchTree() {
        root = null;
    }
    
    void insert(int key) {
        root = insertRec(root, key);
    }
    
    Node insertRec(Node root, int key) {
        if (root == null) {
            root = new Node(key);
            return root;
        }
        
        if (key < root.key)
            root.left = insertRec(root.left, key);
        else if (key > root.key)
            root.right = insertRec(root.right, key);
            
        return root;
    }
    
    void inorder() {
        inorderRec(root);
    }
    
    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.key + "" "");
            inorderRec(root.right);
        }
    }
}",0
"public class BST {
    class TreeNode {
        int value;
        TreeNode left, right;
        
        public TreeNode(int data) {
            value = data;
            left = right = null;
        }
    }
    
    TreeNode root;
    
    BST() {
        root = null;
    }
    
    void add(int value) {
        root = addRecursive(root, value);
    }
    
    TreeNode addRecursive(TreeNode root, int value) {
        if (root == null) {
            root = new TreeNode(value);
            return root;
        }
        
        if (value < root.value)
            root.left = addRecursive(root.left, value);
        else if (value > root.value)
            root.right = addRecursive(root.right, value);
            
        return root;
    }
    
    void printInOrder() {
        traverseInOrder(root);
    }
    
    void traverseInOrder(TreeNode root) {
        if (root != null) {
            traverseInOrder(root.left);
            System.out.print(root.value + "" "");
            traverseInOrder(root.right);
        }
    }
}",1
"#include <cs50.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

bool is_valid_key(string key);
char rotate(char c, string key);

int main(int argc, string argv[])
{
    // Check if only one command-line argument is provided
    if (argc != 2)
    {
        printf(""Usage: ./substitution key\n"");
        return 1;
    }
    
    string key = argv[1];
    
    // Validate key
    if (!is_valid_key(key))
    {
        return 1;
    }
    
    // Get plaintext
    string plaintext = get_string(""plaintext: "");
    printf(""ciphertext: "");
    
    // Encrypt and print ciphertext
    for (int i = 0, n = strlen(plaintext); i < n; i++)
    {
        printf(""%c"", rotate(plaintext[i], key));
    }
    printf(""\n"");
    
    return 0;
}",0
"import re

def is_valid_credit_card(number):
    # Remove spaces and dashes
    number = re.sub(r'[\s-]', '', number)
    
    # Check if it contains only digits
    if not number.isdigit():
        return False
    
    # Check length (13-16 digits)
    if len(number) < 13 or len(number) > 16:
        return False
    
    # Luhn algorithm
    sum = 0
    double = False
    
    # Iterate from right to left
    for digit in reversed(number):
        digit = int(digit)
        
        if double:
            digit *= 2
            if digit > 9:
                digit -= 9
        
        sum += digit
        double = not double
    
    return sum % 10 == 0

card_number = input(""Enter credit card number: "")
if is_valid_credit_card(card_number):
    print(""Valid credit card number"")
else:
    print(""Invalid credit card number"")",0
"def validate_credit_card(card_num):
    # Remove any spaces or hyphens
    card_num = card_num.replace(' ', '').replace('-', '')
    
    # Verify it's all digits
    if not card_num.isdigit():
        return False
    
    # Check length (13-16 digits for most cards)
    if len(card_num) < 13 or len(card_num) > 16:
        return False
    
    # Apply Luhn algorithm
    total = 0
    should_double = False
    
    # Process from right to left
    for digit in reversed(card_num):
        digit = int(digit)
        
        if should_double:
            digit *= 2
            if digit > 9:
                digit -= 9
        
        total += digit
        should_double = not should_double
    
    # Valid if total is divisible by 10
    return total % 10 == 0

# Get user input
number = input(""Enter your credit card number: "")
if validate_credit_card(number):
    print(""This is a valid credit card."")
else:
    print(""This is not a valid credit card."")",1
"import java.util.*;

public class DijkstraAlgorithm {
    static class Node implements Comparable<Node> {
        int vertex;
        int distance;
        
        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    public static int[] dijkstra(List<List<Node>> graph, int start) {
        int n = graph.size();
        int[] distance = new int[n];
        Arrays.fill(distance, Integer.MAX_VALUE);
        distance[start] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(start, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            
            if (current.distance > distance[current.vertex]) {
                continue;
            }
            
            for (Node neighbor : graph.get(current.vertex)) {
                int newDistance = distance[current.vertex] + neighbor.distance;
                
                if (newDistance < distance[neighbor.vertex]) {
                    distance[neighbor.vertex] = newDistance;
                    pq.add(new Node(neighbor.vertex, newDistance));
                }
            }
        }
        
        return distance;
    }
}",0
"import java.util.*;

public class ShortestPath {
    static class Vertex implements Comparable<Vertex> {
        int id;
        int dist;
        
        public Vertex(int id, int dist) {
            this.id = id;
            this.dist = dist;
        }
        
        @Override
        public int compareTo(Vertex other) {
            return Integer.compare(this.dist, other.dist);
        }
    }
    
    public static int[] findShortestPaths(List<List<Vertex>> adjList, int source) {
        int vertices = adjList.size();
        int[] distances = new int[vertices];
        Arrays.fill(distances, Integer.MAX_VALUE);
        distances[source] = 0;
        
        PriorityQueue<Vertex> queue = new PriorityQueue<>();
        queue.add(new Vertex(source, 0));
        
        while (!queue.isEmpty()) {
            Vertex current = queue.poll();
            
            if (current.dist > distances[current.id]) {
                continue;
            }
            
            for (Vertex neighbor : adjList.get(current.id)) {
                int newDist = distances[current.id] + neighbor.dist;
                
                if (newDist < distances[neighbor.id]) {
                    distances[neighbor.id] = newDist;
                    queue.add(new Vertex(neighbor.id, newDist));
                }
            }
        }
        
        return distances;
    }
}",1
"def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr",0
"def sort_array(elements):
    for index in range(1, len(elements)):
        current = elements[index]
        position = index - 1
        while position >= 0 and elements[position] > current:
            elements[position + 1] = elements[position]
            position -= 1
        elements[position + 1] = current
    return elements",1
